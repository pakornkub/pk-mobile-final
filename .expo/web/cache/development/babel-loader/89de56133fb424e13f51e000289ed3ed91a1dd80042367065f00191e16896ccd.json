{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport { useRef as $eCAIO$useRef, useEffect as $eCAIO$useEffect, useMemo as $eCAIO$useMemo } from \"react\";\nimport { getFocusableTreeWalker as $eCAIO$getFocusableTreeWalker, focusSafely as $eCAIO$focusSafely } from \"@react-aria/focus\";\nimport { focusWithoutScrolling as $eCAIO$focusWithoutScrolling, useEvent as $eCAIO$useEvent, scrollIntoView as $eCAIO$scrollIntoView, mergeProps as $eCAIO$mergeProps, isAppleDevice as $eCAIO$isAppleDevice, isMac as $eCAIO$isMac } from \"@react-aria/utils\";\nimport { useLocale as $eCAIO$useLocale, useCollator as $eCAIO$useCollator } from \"@react-aria/i18n\";\nimport { usePress as $eCAIO$usePress, useLongPress as $eCAIO$useLongPress } from \"@react-aria/interactions\";\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\nvar $ae20dd8cbca75726$exports = {};\n$parcel$export($ae20dd8cbca75726$exports, \"useSelectableCollection\", function () {\n  return $ae20dd8cbca75726$export$d6daf82dcd84e87c;\n});\nfunction $feb5ffebff200149$export$d3e3bd3e26688c04(e) {\n  return $eCAIO$isAppleDevice() ? e.altKey : e.ctrlKey;\n}\nfunction $feb5ffebff200149$export$16792effe837dba3(e) {\n  if ($eCAIO$isMac()) return e.metaKey;\n  return e.ctrlKey;\n}\nvar $fb3050f43d946246$exports = {};\n$parcel$export($fb3050f43d946246$exports, \"useTypeSelect\", function () {\n  return $fb3050f43d946246$export$e32c88dfddc6e1d8;\n});\nfunction $fb3050f43d946246$export$e32c88dfddc6e1d8(options) {\n  var keyboardDelegate = options.keyboardDelegate,\n    selectionManager = options.selectionManager,\n    onTypeSelect = options.onTypeSelect;\n  var state = $eCAIO$useRef({\n    search: '',\n    timeout: null\n  }).current;\n  var onKeyDown = function onKeyDown(e) {\n    var character = $fb3050f43d946246$var$getStringForKey(e.key);\n    if (!character || e.ctrlKey || e.metaKey) return;\n    if (character === ' ' && state.search.trim().length > 0) {\n      e.preventDefault();\n      if (!('continuePropagation' in e)) e.stopPropagation();\n    }\n    state.search += character;\n    var key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);\n    if (key == null) key = keyboardDelegate.getKeyForSearch(state.search);\n    if (key != null) {\n      selectionManager.setFocusedKey(key);\n      if (onTypeSelect) onTypeSelect(key);\n    }\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function () {\n      state.search = '';\n    }, 500);\n  };\n  return {\n    typeSelectProps: {\n      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null\n    }\n  };\n}\nfunction $fb3050f43d946246$var$getStringForKey(key) {\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) return key;\n  return '';\n}\nfunction $ae20dd8cbca75726$export$d6daf82dcd84e87c(options) {\n  var manager = options.selectionManager,\n    delegate = options.keyboardDelegate,\n    ref = options.ref,\n    _options$autoFocus = options.autoFocus,\n    autoFocus = _options$autoFocus === void 0 ? false : _options$autoFocus,\n    _options$shouldFocusW = options.shouldFocusWrap,\n    shouldFocusWrap = _options$shouldFocusW === void 0 ? false : _options$shouldFocusW,\n    _options$disallowEmpt = options.disallowEmptySelection,\n    disallowEmptySelection = _options$disallowEmpt === void 0 ? false : _options$disallowEmpt,\n    _options$disallowSele = options.disallowSelectAll,\n    disallowSelectAll = _options$disallowSele === void 0 ? false : _options$disallowSele,\n    _options$selectOnFocu = options.selectOnFocus,\n    selectOnFocus = _options$selectOnFocu === void 0 ? manager.selectionBehavior === 'replace' : _options$selectOnFocu,\n    _options$disallowType = options.disallowTypeAhead,\n    disallowTypeAhead = _options$disallowType === void 0 ? false : _options$disallowType,\n    shouldUseVirtualFocus = options.shouldUseVirtualFocus,\n    _options$allowsTabNav = options.allowsTabNavigation,\n    allowsTabNavigation = _options$allowsTabNav === void 0 ? false : _options$allowsTabNav,\n    isVirtualized = options.isVirtualized,\n    _options$scrollRef = options.scrollRef,\n    scrollRef = _options$scrollRef === void 0 ? ref : _options$scrollRef;\n  var _$eCAIO$useLocale = $eCAIO$useLocale(),\n    direction = _$eCAIO$useLocale.direction;\n  var onKeyDown = function onKeyDown(e) {\n    if (e.altKey && e.key === 'Tab') e.preventDefault();\n    if (!ref.current.contains(e.target)) return;\n    var navigateToKey = function navigateToKey(key, childFocus) {\n      if (key != null) {\n        manager.setFocusedKey(key, childFocus);\n        if (e.shiftKey && manager.selectionMode === 'multiple') manager.extendSelection(key);else if (selectOnFocus && !$feb5ffebff200149$export$d3e3bd3e26688c04(e)) manager.replaceSelection(key);\n      }\n    };\n    switch (e.key) {\n      case 'ArrowDown':\n        if (delegate.getKeyBelow) {\n          var ref4, ref1;\n          e.preventDefault();\n          var nextKey = manager.focusedKey != null ? delegate.getKeyBelow(manager.focusedKey) : (ref4 = delegate.getFirstKey) === null || ref4 === void 0 ? void 0 : ref4.call(delegate);\n          if (nextKey == null && shouldFocusWrap) nextKey = (ref1 = delegate.getFirstKey) === null || ref1 === void 0 ? void 0 : ref1.call(delegate, manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'ArrowUp':\n        if (delegate.getKeyAbove) {\n          var ref2, ref3;\n          e.preventDefault();\n          var _nextKey = manager.focusedKey != null ? delegate.getKeyAbove(manager.focusedKey) : (ref2 = delegate.getLastKey) === null || ref2 === void 0 ? void 0 : ref2.call(delegate);\n          if (_nextKey == null && shouldFocusWrap) _nextKey = (ref3 = delegate.getLastKey) === null || ref3 === void 0 ? void 0 : ref3.call(delegate, manager.focusedKey);\n          navigateToKey(_nextKey);\n        }\n        break;\n      case 'ArrowLeft':\n        if (delegate.getKeyLeftOf) {\n          e.preventDefault();\n          var _nextKey2 = delegate.getKeyLeftOf(manager.focusedKey);\n          navigateToKey(_nextKey2, direction === 'rtl' ? 'first' : 'last');\n        }\n        break;\n      case 'ArrowRight':\n        if (delegate.getKeyRightOf) {\n          e.preventDefault();\n          var _nextKey3 = delegate.getKeyRightOf(manager.focusedKey);\n          navigateToKey(_nextKey3, direction === 'rtl' ? 'last' : 'first');\n        }\n        break;\n      case 'Home':\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          var firstKey = delegate.getFirstKey(manager.focusedKey, $feb5ffebff200149$export$16792effe837dba3(e));\n          manager.setFocusedKey(firstKey);\n          if ($feb5ffebff200149$export$16792effe837dba3(e) && e.shiftKey && manager.selectionMode === 'multiple') manager.extendSelection(firstKey);else if (selectOnFocus) manager.replaceSelection(firstKey);\n        }\n        break;\n      case 'End':\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          var lastKey = delegate.getLastKey(manager.focusedKey, $feb5ffebff200149$export$16792effe837dba3(e));\n          manager.setFocusedKey(lastKey);\n          if ($feb5ffebff200149$export$16792effe837dba3(e) && e.shiftKey && manager.selectionMode === 'multiple') manager.extendSelection(lastKey);else if (selectOnFocus) manager.replaceSelection(lastKey);\n        }\n        break;\n      case 'PageDown':\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n          var _nextKey4 = delegate.getKeyPageBelow(manager.focusedKey);\n          navigateToKey(_nextKey4);\n        }\n        break;\n      case 'PageUp':\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n          var _nextKey5 = delegate.getKeyPageAbove(manager.focusedKey);\n          navigateToKey(_nextKey5);\n        }\n        break;\n      case 'a':\n        if ($feb5ffebff200149$export$16792effe837dba3(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n        break;\n      case 'Escape':\n        e.preventDefault();\n        if (!disallowEmptySelection) manager.clearSelection();\n        break;\n      case 'Tab':\n        if (!allowsTabNavigation) {\n          if (e.shiftKey) ref.current.focus();else {\n            var walker = $eCAIO$getFocusableTreeWalker(ref.current, {\n              tabbable: true\n            });\n            var next;\n            var last;\n            do {\n              last = walker.lastChild();\n              if (last) next = last;\n            } while (last);\n            if (next && !next.contains(document.activeElement)) $eCAIO$focusWithoutScrolling(next);\n          }\n          break;\n        }\n    }\n  };\n  var scrollPos = $eCAIO$useRef({\n    top: 0,\n    left: 0\n  });\n  $eCAIO$useEvent(scrollRef, 'scroll', isVirtualized ? null : function () {\n    scrollPos.current = {\n      top: scrollRef.current.scrollTop,\n      left: scrollRef.current.scrollLeft\n    };\n  });\n  var onFocus = function onFocus(e) {\n    if (manager.isFocused) {\n      if (!e.currentTarget.contains(e.target)) manager.setFocused(false);\n      return;\n    }\n    if (!e.currentTarget.contains(e.target)) return;\n    manager.setFocused(true);\n    if (manager.focusedKey == null) {\n      var navigateToFirstKey = function navigateToFirstKey(key) {\n        if (key != null) {\n          manager.setFocusedKey(key);\n          if (selectOnFocus) manager.replaceSelection(key);\n        }\n      };\n      var relatedTarget = e.relatedTarget;\n      var _lastSelectedKey, _firstSelectedKey;\n      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) navigateToFirstKey((_lastSelectedKey = manager.lastSelectedKey) !== null && _lastSelectedKey !== void 0 ? _lastSelectedKey : delegate.getLastKey());else navigateToFirstKey((_firstSelectedKey = manager.firstSelectedKey) !== null && _firstSelectedKey !== void 0 ? _firstSelectedKey : delegate.getFirstKey());\n    } else if (!isVirtualized) {\n      scrollRef.current.scrollTop = scrollPos.current.top;\n      scrollRef.current.scrollLeft = scrollPos.current.left;\n      var element = scrollRef.current.querySelector(\"[data-key=\\\"\" + manager.focusedKey + \"\\\"]\");\n      if (element) {\n        $eCAIO$focusWithoutScrolling(element);\n        $eCAIO$scrollIntoView(scrollRef.current, element);\n      }\n    }\n  };\n  var onBlur = function onBlur(e) {\n    if (!e.currentTarget.contains(e.relatedTarget)) manager.setFocused(false);\n  };\n  var autoFocusRef = $eCAIO$useRef(autoFocus);\n  $eCAIO$useEffect(function () {\n    if (autoFocusRef.current) {\n      var focusedKey = null;\n      if (autoFocus === 'first') focusedKey = delegate.getFirstKey();\n      if (autoFocus === 'last') focusedKey = delegate.getLastKey();\n      var selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) focusedKey = selectedKeys.values().next().value;\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n      if (focusedKey == null && !shouldUseVirtualFocus) $eCAIO$focusSafely(ref.current);\n    }\n    autoFocusRef.current = false;\n  }, []);\n  $eCAIO$useEffect(function () {\n    if (!isVirtualized && manager.focusedKey && (scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current)) {\n      var element = scrollRef.current.querySelector(\"[data-key=\\\"\" + manager.focusedKey + \"\\\"]\");\n      if (element) $eCAIO$scrollIntoView(scrollRef.current, element);\n    }\n  }, [isVirtualized, scrollRef, manager.focusedKey]);\n  var handlers = {\n    onKeyDown: onKeyDown,\n    onFocus: onFocus,\n    onBlur: onBlur,\n    onMouseDown: function onMouseDown(e) {\n      if (e.currentTarget.contains(e.target)) e.preventDefault();\n    }\n  };\n  var _$fb3050f43d946246$ex = $fb3050f43d946246$export$e32c88dfddc6e1d8({\n      keyboardDelegate: delegate,\n      selectionManager: manager\n    }),\n    typeSelectProps = _$fb3050f43d946246$ex.typeSelectProps;\n  if (!disallowTypeAhead) handlers = $eCAIO$mergeProps(typeSelectProps, handlers);\n  var tabIndex;\n  if (!shouldUseVirtualFocus) tabIndex = manager.focusedKey == null ? 0 : -1;\n  return {\n    collectionProps: _objectSpread(_objectSpread({}, handlers), {}, {\n      tabIndex: tabIndex\n    })\n  };\n}\nvar $880e95eb8b93ba9a$exports = {};\n$parcel$export($880e95eb8b93ba9a$exports, \"useSelectableItem\", function () {\n  return $880e95eb8b93ba9a$export$ecf600387e221c37;\n});\nfunction $880e95eb8b93ba9a$export$ecf600387e221c37(options) {\n  var manager = options.selectionManager,\n    key = options.key,\n    ref = options.ref,\n    shouldSelectOnPressUp = options.shouldSelectOnPressUp,\n    isVirtualized = options.isVirtualized,\n    shouldUseVirtualFocus = options.shouldUseVirtualFocus,\n    focus = options.focus,\n    isDisabled = options.isDisabled,\n    onAction = options.onAction,\n    allowsDifferentPressOrigin = options.allowsDifferentPressOrigin;\n  var onSelect = function onSelect(e) {\n    if (e.pointerType === 'keyboard' && $feb5ffebff200149$export$d3e3bd3e26688c04(e)) manager.toggleSelection(key);else {\n      if (manager.selectionMode === 'none') return;\n      if (manager.selectionMode === 'single') {\n        if (manager.isSelected(key) && !manager.disallowEmptySelection) manager.toggleSelection(key);else manager.replaceSelection(key);\n      } else if (e && e.shiftKey) manager.extendSelection(key);else if (manager.selectionBehavior === 'toggle' || e && ($feb5ffebff200149$export$16792effe837dba3(e) || e.pointerType === 'touch' || e.pointerType === 'virtual')) manager.toggleSelection(key);else manager.replaceSelection(key);\n    }\n  };\n  $eCAIO$useEffect(function () {\n    var isFocused = key === manager.focusedKey;\n    if (isFocused && manager.isFocused && !shouldUseVirtualFocus && document.activeElement !== ref.current) {\n      if (focus) focus();else $eCAIO$focusSafely(ref.current);\n    }\n  }, [ref, key, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]);\n  var itemProps = {};\n  if (!shouldUseVirtualFocus) itemProps = {\n    tabIndex: key === manager.focusedKey ? 0 : -1,\n    onFocus: function onFocus(e) {\n      if (e.target === ref.current) manager.setFocusedKey(key);\n    }\n  };\n  isDisabled = isDisabled || manager.isDisabled(key);\n  var allowsSelection = !isDisabled && manager.canSelectItem(key);\n  var allowsActions = onAction && !isDisabled;\n  var hasPrimaryAction = allowsActions && (manager.selectionBehavior === 'replace' ? !allowsSelection : manager.isEmpty);\n  var hasSecondaryAction = allowsActions && allowsSelection && manager.selectionBehavior === 'replace';\n  var hasAction = hasPrimaryAction || hasSecondaryAction;\n  var modality = $eCAIO$useRef(null);\n  var longPressEnabled = hasAction && allowsSelection;\n  var longPressEnabledOnPressStart = $eCAIO$useRef(false);\n  var hadPrimaryActionOnPressStart = $eCAIO$useRef(false);\n  var itemPressProps = {};\n  if (shouldSelectOnPressUp) {\n    itemPressProps.onPressStart = function (e) {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      if (e.pointerType === 'keyboard' && (!hasAction || $880e95eb8b93ba9a$var$isSelectionKey())) onSelect(e);\n    };\n    if (!allowsDifferentPressOrigin) itemPressProps.onPress = function (e) {\n      if (hasPrimaryAction || hasSecondaryAction && e.pointerType !== 'mouse') {\n        if (e.pointerType === 'keyboard' && !$880e95eb8b93ba9a$var$isActionKey()) return;\n        onAction();\n      } else if (e.pointerType !== 'keyboard') onSelect(e);\n    };else {\n      itemPressProps.onPressUp = function (e) {\n        if (e.pointerType !== 'keyboard') onSelect(e);\n      };\n      itemPressProps.onPress = hasPrimaryAction ? function () {\n        return onAction();\n      } : null;\n    }\n  } else {\n    itemPressProps.onPressStart = function (e) {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      hadPrimaryActionOnPressStart.current = hasPrimaryAction;\n      if (e.pointerType === 'mouse' && !hasPrimaryAction || e.pointerType === 'keyboard' && (!onAction || $880e95eb8b93ba9a$var$isSelectionKey())) onSelect(e);\n    };\n    itemPressProps.onPress = function (e) {\n      if (e.pointerType === 'touch' || e.pointerType === 'pen' || e.pointerType === 'virtual' || e.pointerType === 'keyboard' && hasAction && $880e95eb8b93ba9a$var$isActionKey() || e.pointerType === 'mouse' && hadPrimaryActionOnPressStart.current) {\n        if (hasAction) onAction();else onSelect(e);\n      }\n    };\n  }\n  if (!isVirtualized) itemProps['data-key'] = key;\n  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;\n  var _$eCAIO$usePress = $eCAIO$usePress(itemPressProps),\n    pressProps = _$eCAIO$usePress.pressProps,\n    isPressed = _$eCAIO$usePress.isPressed;\n  var onDoubleClick = hasSecondaryAction ? function (e) {\n    if (modality.current === 'mouse') {\n      e.stopPropagation();\n      e.preventDefault();\n      onAction();\n    }\n  } : undefined;\n  var _$eCAIO$useLongPress = $eCAIO$useLongPress({\n      isDisabled: !longPressEnabled,\n      onLongPress: function onLongPress(e) {\n        if (e.pointerType === 'touch') {\n          onSelect(e);\n          manager.setSelectionBehavior('toggle');\n        }\n      }\n    }),\n    longPressProps = _$eCAIO$useLongPress.longPressProps;\n  var onDragStart = function onDragStart(e) {\n    if (modality.current === 'touch' && longPressEnabledOnPressStart.current) e.preventDefault();\n  };\n  return {\n    itemProps: $eCAIO$mergeProps(itemProps, allowsSelection || hasPrimaryAction ? pressProps : {}, longPressEnabled ? longPressProps : {}, {\n      onDoubleClick: onDoubleClick,\n      onDragStart: onDragStart\n    }),\n    isPressed: isPressed,\n    isSelected: manager.isSelected(key),\n    isDisabled: isDisabled,\n    allowsSelection: allowsSelection,\n    hasAction: hasAction\n  };\n}\nfunction $880e95eb8b93ba9a$var$isActionKey() {\n  var event = window.event;\n  return (event === null || event === void 0 ? void 0 : event.key) === 'Enter';\n}\nfunction $880e95eb8b93ba9a$var$isSelectionKey() {\n  var event = window.event;\n  return (event === null || event === void 0 ? void 0 : event.key) === ' ' || (event === null || event === void 0 ? void 0 : event.code) === 'Space';\n}\nvar $982254629710d113$exports = {};\n$parcel$export($982254629710d113$exports, \"useSelectableList\", function () {\n  return $982254629710d113$export$b95089534ab7c1fd;\n});\nvar $2a25aae57d74318e$exports = {};\n$parcel$export($2a25aae57d74318e$exports, \"ListKeyboardDelegate\", function () {\n  return $2a25aae57d74318e$export$a05409b8bb224a5a;\n});\nvar $2a25aae57d74318e$export$a05409b8bb224a5a = function () {\n  function $2a25aae57d74318e$export$a05409b8bb224a5a(collection, disabledKeys, ref, collator) {\n    _classCallCheck(this, $2a25aae57d74318e$export$a05409b8bb224a5a);\n    this.collection = collection;\n    this.disabledKeys = disabledKeys;\n    this.ref = ref;\n    this.collator = collator;\n  }\n  _createClass($2a25aae57d74318e$export$a05409b8bb224a5a, [{\n    key: \"getKeyBelow\",\n    value: function getKeyBelow(key) {\n      key = this.collection.getKeyAfter(key);\n      while (key != null) {\n        var item = this.collection.getItem(key);\n        if (item.type === 'item' && !this.disabledKeys.has(key)) return key;\n        key = this.collection.getKeyAfter(key);\n      }\n    }\n  }, {\n    key: \"getKeyAbove\",\n    value: function getKeyAbove(key) {\n      key = this.collection.getKeyBefore(key);\n      while (key != null) {\n        var item = this.collection.getItem(key);\n        if (item.type === 'item' && !this.disabledKeys.has(key)) return key;\n        key = this.collection.getKeyBefore(key);\n      }\n    }\n  }, {\n    key: \"getFirstKey\",\n    value: function getFirstKey() {\n      var key = this.collection.getFirstKey();\n      while (key != null) {\n        var item = this.collection.getItem(key);\n        if (item.type === 'item' && !this.disabledKeys.has(key)) return key;\n        key = this.collection.getKeyAfter(key);\n      }\n    }\n  }, {\n    key: \"getLastKey\",\n    value: function getLastKey() {\n      var key = this.collection.getLastKey();\n      while (key != null) {\n        var item = this.collection.getItem(key);\n        if (item.type === 'item' && !this.disabledKeys.has(key)) return key;\n        key = this.collection.getKeyBefore(key);\n      }\n    }\n  }, {\n    key: \"getItem\",\n    value: function getItem(key) {\n      return this.ref.current.querySelector(\"[data-key=\\\"\" + key + \"\\\"]\");\n    }\n  }, {\n    key: \"getKeyPageAbove\",\n    value: function getKeyPageAbove(key) {\n      var menu = this.ref.current;\n      var item = this.getItem(key);\n      if (!item) return null;\n      var pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);\n      while (item && item.offsetTop > pageY) {\n        key = this.getKeyAbove(key);\n        item = this.getItem(key);\n      }\n      return key;\n    }\n  }, {\n    key: \"getKeyPageBelow\",\n    value: function getKeyPageBelow(key) {\n      var menu = this.ref.current;\n      var item = this.getItem(key);\n      if (!item) return null;\n      var pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);\n      while (item && item.offsetTop < pageY) {\n        key = this.getKeyBelow(key);\n        item = this.getItem(key);\n      }\n      return key;\n    }\n  }, {\n    key: \"getKeyForSearch\",\n    value: function getKeyForSearch(search, fromKey) {\n      if (!this.collator) return null;\n      var collection = this.collection;\n      var key = fromKey || this.getFirstKey();\n      while (key != null) {\n        var item = collection.getItem(key);\n        var substring = item.textValue.slice(0, search.length);\n        if (item.textValue && this.collator.compare(substring, search) === 0) return key;\n        key = this.getKeyBelow(key);\n      }\n      return null;\n    }\n  }]);\n  return $2a25aae57d74318e$export$a05409b8bb224a5a;\n}();\nfunction $982254629710d113$export$b95089534ab7c1fd(props) {\n  var selectionManager = props.selectionManager,\n    collection = props.collection,\n    disabledKeys = props.disabledKeys,\n    ref = props.ref,\n    keyboardDelegate = props.keyboardDelegate,\n    autoFocus = props.autoFocus,\n    shouldFocusWrap = props.shouldFocusWrap,\n    isVirtualized = props.isVirtualized,\n    disallowEmptySelection = props.disallowEmptySelection,\n    _props$selectOnFocus = props.selectOnFocus,\n    selectOnFocus = _props$selectOnFocus === void 0 ? false : _props$selectOnFocus,\n    disallowTypeAhead = props.disallowTypeAhead,\n    shouldUseVirtualFocus = props.shouldUseVirtualFocus,\n    allowsTabNavigation = props.allowsTabNavigation;\n  var collator = $eCAIO$useCollator({\n    usage: 'search',\n    sensitivity: 'base'\n  });\n  var delegate = $eCAIO$useMemo(function () {\n    return keyboardDelegate || new $2a25aae57d74318e$export$a05409b8bb224a5a(collection, disabledKeys, ref, collator);\n  }, [keyboardDelegate, collection, disabledKeys, ref, collator]);\n  var _$ae20dd8cbca75726$ex = $ae20dd8cbca75726$export$d6daf82dcd84e87c({\n      ref: ref,\n      selectionManager: selectionManager,\n      keyboardDelegate: delegate,\n      autoFocus: autoFocus,\n      shouldFocusWrap: shouldFocusWrap,\n      disallowEmptySelection: disallowEmptySelection,\n      selectOnFocus: selectOnFocus,\n      disallowTypeAhead: disallowTypeAhead,\n      shouldUseVirtualFocus: shouldUseVirtualFocus,\n      allowsTabNavigation: allowsTabNavigation,\n      isVirtualized: isVirtualized,\n      scrollRef: ref\n    }),\n    collectionProps = _$ae20dd8cbca75726$ex.collectionProps;\n  return {\n    listProps: collectionProps\n  };\n}\nexport { $ae20dd8cbca75726$export$d6daf82dcd84e87c as useSelectableCollection, $880e95eb8b93ba9a$export$ecf600387e221c37 as useSelectableItem, $982254629710d113$export$b95089534ab7c1fd as useSelectableList, $2a25aae57d74318e$export$a05409b8bb224a5a as ListKeyboardDelegate, $fb3050f43d946246$export$e32c88dfddc6e1d8 as useTypeSelect };","map":{"version":3,"names":["$feb5ffebff200149$export$d3e3bd3e26688c04","e","$eCAIO$isAppleDevice","altKey","ctrlKey","$feb5ffebff200149$export$16792effe837dba3","$eCAIO$isMac","metaKey","$fb3050f43d946246$export$e32c88dfddc6e1d8","options","keyboardDelegate","selectionManager","onTypeSelect","state","$eCAIO$useRef","search","timeout","current","onKeyDown","character","$fb3050f43d946246$var$getStringForKey","key","trim","length","preventDefault","stopPropagation","getKeyForSearch","focusedKey","setFocusedKey","clearTimeout","setTimeout","typeSelectProps","onKeyDownCapture","test","$ae20dd8cbca75726$export$d6daf82dcd84e87c","manager","delegate","ref","_options$autoFocus","autoFocus","_options$shouldFocusW","shouldFocusWrap","_options$disallowEmpt","disallowEmptySelection","_options$disallowSele","disallowSelectAll","_options$selectOnFocu","selectOnFocus","selectionBehavior","_options$disallowType","disallowTypeAhead","shouldUseVirtualFocus","_options$allowsTabNav","allowsTabNavigation","isVirtualized","_options$scrollRef","scrollRef","_$eCAIO$useLocale","$eCAIO$useLocale","direction","contains","target","navigateToKey","childFocus","shiftKey","selectionMode","extendSelection","replaceSelection","getKeyBelow","ref4","ref1","nextKey","getFirstKey","call","getKeyAbove","ref2","ref3","getLastKey","getKeyLeftOf","getKeyRightOf","firstKey","lastKey","getKeyPageBelow","getKeyPageAbove","selectAll","clearSelection","focus","walker","$eCAIO$getFocusableTreeWalker","tabbable","next","last","lastChild","document","activeElement","$eCAIO$focusWithoutScrolling","scrollPos","top","left","$eCAIO$useEvent","scrollTop","scrollLeft","onFocus","isFocused","currentTarget","setFocused","navigateToFirstKey","relatedTarget","_lastSelectedKey","_firstSelectedKey","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","lastSelectedKey","firstSelectedKey","element","querySelector","$eCAIO$scrollIntoView","onBlur","autoFocusRef","$eCAIO$useEffect","selectedKeys","size","values","value","$eCAIO$focusSafely","handlers","onMouseDown","_$fb3050f43d946246$ex","$eCAIO$mergeProps","tabIndex","collectionProps","_objectSpread","$880e95eb8b93ba9a$export$ecf600387e221c37","shouldSelectOnPressUp","isDisabled","onAction","allowsDifferentPressOrigin","onSelect","pointerType","toggleSelection","isSelected","childFocusStrategy","itemProps","allowsSelection","canSelectItem","allowsActions","hasPrimaryAction","isEmpty","hasSecondaryAction","hasAction","modality","longPressEnabled","longPressEnabledOnPressStart","hadPrimaryActionOnPressStart","itemPressProps","onPressStart","$880e95eb8b93ba9a$var$isSelectionKey","onPress","$880e95eb8b93ba9a$var$isActionKey","onPressUp","preventFocusOnPress","_$eCAIO$usePress","$eCAIO$usePress","pressProps","isPressed","onDoubleClick","undefined","_$eCAIO$useLongPress","$eCAIO$useLongPress","onLongPress","setSelectionBehavior","longPressProps","onDragStart","event","window","code","$2a25aae57d74318e$export$a05409b8bb224a5a","collection","disabledKeys","collator","_classCallCheck","_createClass","getKeyAfter","item","getItem","type","has","getKeyBefore","menu","pageY","Math","max","offsetTop","offsetHeight","min","scrollHeight","fromKey","substring","textValue","slice","compare","$982254629710d113$export$b95089534ab7c1fd","props","_props$selectOnFocus","$eCAIO$useCollator","usage","sensitivity","$eCAIO$useMemo","_$ae20dd8cbca75726$ex","listProps"],"sources":["D:\\_Dev\\expo\\pk-mobile\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\index.ts","D:\\_Dev\\expo\\pk-mobile\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\useSelectableCollection.ts","D:\\_Dev\\expo\\pk-mobile\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\utils.ts","D:\\_Dev\\expo\\pk-mobile\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\useTypeSelect.ts","D:\\_Dev\\expo\\pk-mobile\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\useSelectableItem.ts","D:\\_Dev\\expo\\pk-mobile\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\useSelectableList.ts","D:\\_Dev\\expo\\pk-mobile\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\ListKeyboardDelegate.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport * from './useSelectableCollection';\nexport * from './useSelectableItem';\nexport * from './useSelectableList';\nexport * from './ListKeyboardDelegate';\nexport * from './useTypeSelect';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusEvent, HTMLAttributes, Key, KeyboardEvent, RefObject, useEffect, useRef} from 'react';\nimport {focusSafely, getFocusableTreeWalker} from '@react-aria/focus';\nimport {FocusStrategy, KeyboardDelegate} from '@react-types/shared';\nimport {focusWithoutScrolling, mergeProps, scrollIntoView, useEvent} from '@react-aria/utils';\nimport {isCtrlKeyPressed, isNonContiguousSelectionModifier} from './utils';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useLocale} from '@react-aria/i18n';\nimport {useTypeSelect} from './useTypeSelect';\n\ninterface SelectableCollectionOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A delegate object that implements behavior for keyboard focus movement.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * The ref attached to the element representing the collection.\n   */\n  ref: RefObject<HTMLElement>,\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy,\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean,\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean,\n  /**\n   * Whether the collection allows the user to select all items via keyboard shortcut.\n   * @default false\n   */\n  disallowSelectAll?: boolean,\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean,\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean,\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /**\n   * Whether navigation through tab key is enabled.\n   */\n  allowsTabNavigation?: boolean,\n  /**\n   * Whether the collection items are contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * The ref attached to the scrollable body. Used to provide automatic scrolling on item focus for non-virtualized collections.\n   * If not provided, defaults to the collection ref.\n   */\n  scrollRef?: RefObject<HTMLElement>\n}\n\ninterface SelectableCollectionAria {\n  /** Props for the collection element. */\n  collectionProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Handles interactions with selectable collections.\n */\nexport function useSelectableCollection(options: SelectableCollectionOptions): SelectableCollectionAria {\n  let {\n    selectionManager: manager,\n    keyboardDelegate: delegate,\n    ref,\n    autoFocus = false,\n    shouldFocusWrap = false,\n    disallowEmptySelection = false,\n    disallowSelectAll = false,\n    selectOnFocus = manager.selectionBehavior === 'replace',\n    disallowTypeAhead = false,\n    shouldUseVirtualFocus,\n    allowsTabNavigation = false,\n    isVirtualized,\n    // If no scrollRef is provided, assume the collection ref is the scrollable region\n    scrollRef = ref\n  } = options;\n  let {direction} = useLocale();\n\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes\n    if (e.altKey && e.key === 'Tab') {\n      e.preventDefault();\n    }\n\n    // Keyboard events bubble through portals. Don't handle keyboard events\n    // for elements outside the collection (e.g. menus).\n    if (!ref.current.contains(e.target as HTMLElement)) {\n      return;\n    }\n\n    const navigateToKey = (key: Key | undefined, childFocus?: FocusStrategy) => {\n      if (key != null) {\n        manager.setFocusedKey(key, childFocus);\n\n        if (e.shiftKey && manager.selectionMode === 'multiple') {\n          manager.extendSelection(key);\n        } else if (selectOnFocus && !isNonContiguousSelectionModifier(e)) {\n          manager.replaceSelection(key);\n        }\n      }\n    };\n\n    switch (e.key) {\n      case 'ArrowDown': {\n        if (delegate.getKeyBelow) {\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyBelow(manager.focusedKey)\n              : delegate.getFirstKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getFirstKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case 'ArrowUp': {\n        if (delegate.getKeyAbove) {\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyAbove(manager.focusedKey)\n              : delegate.getLastKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getLastKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case 'ArrowLeft': {\n        if (delegate.getKeyLeftOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyLeftOf(manager.focusedKey);\n          navigateToKey(nextKey, direction === 'rtl' ? 'first' : 'last');\n        }\n        break;\n      }\n      case 'ArrowRight': {\n        if (delegate.getKeyRightOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyRightOf(manager.focusedKey);\n          navigateToKey(nextKey, direction === 'rtl' ? 'last' : 'first');\n        }\n        break;\n      }\n      case 'Home':\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          let firstKey = delegate.getFirstKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(firstKey);\n          if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(firstKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(firstKey);\n          }\n        }\n        break;\n      case 'End':\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          let lastKey = delegate.getLastKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(lastKey);\n          if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(lastKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(lastKey);\n          }\n        }\n        break;\n      case 'PageDown':\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'PageUp':\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'a':\n        if (isCtrlKeyPressed(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n        break;\n      case 'Escape':\n        e.preventDefault();\n        if (!disallowEmptySelection) {\n          manager.clearSelection();\n        }\n        break;\n      case 'Tab': {\n        if (!allowsTabNavigation) {\n          // There may be elements that are \"tabbable\" inside a collection (e.g. in a grid cell).\n          // However, collections should be treated as a single tab stop, with arrow key navigation internally.\n          // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.\n          // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element\n          // in the collection, so that the browser default behavior will apply starting from that element\n          // rather than the currently focused one.\n          if (e.shiftKey) {\n            ref.current.focus();\n          } else {\n            let walker = getFocusableTreeWalker(ref.current, {tabbable: true});\n            let next: HTMLElement;\n            let last: HTMLElement;\n            do {\n              last = walker.lastChild() as HTMLElement;\n              if (last) {\n                next = last;\n              }\n            } while (last);\n\n            if (next && !next.contains(document.activeElement)) {\n              focusWithoutScrolling(next);\n            }\n          }\n          break;\n        }\n      }\n    }\n  };\n\n  // Store the scroll position so we can restore it later.\n  let scrollPos = useRef({top: 0, left: 0});\n  useEvent(scrollRef, 'scroll', isVirtualized ? null : () => {\n    scrollPos.current = {\n      top: scrollRef.current.scrollTop,\n      left: scrollRef.current.scrollLeft\n    };\n  });\n\n  let onFocus = (e: FocusEvent) => {\n    if (manager.isFocused) {\n      // If a focus event bubbled through a portal, reset focus state.\n      if (!e.currentTarget.contains(e.target)) {\n        manager.setFocused(false);\n      }\n\n      return;\n    }\n\n    // Focus events can bubble through portals. Ignore these events.\n    if (!e.currentTarget.contains(e.target)) {\n      return;\n    }\n\n    manager.setFocused(true);\n\n    if (manager.focusedKey == null) {\n      let navigateToFirstKey = (key: Key | undefined) => {\n        if (key != null) {\n          manager.setFocusedKey(key);\n          if (selectOnFocus) {\n            manager.replaceSelection(key);\n          }\n        }\n      };\n      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.\n      // Attempt to detect whether the user is tabbing forward or backward into the collection\n      // and either focus the first or last item accordingly.\n      let relatedTarget = e.relatedTarget as Element;\n      if (relatedTarget && (e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING)) {\n        navigateToFirstKey(manager.lastSelectedKey ?? delegate.getLastKey());\n      } else {\n        navigateToFirstKey(manager.firstSelectedKey ?? delegate.getFirstKey());\n      }\n    } else if (!isVirtualized) {\n      // Restore the scroll position to what it was before.\n      scrollRef.current.scrollTop = scrollPos.current.top;\n      scrollRef.current.scrollLeft = scrollPos.current.left;\n\n      // Refocus and scroll the focused item into view if it exists within the scrollable region.\n      let element = scrollRef.current.querySelector(`[data-key=\"${manager.focusedKey}\"]`) as HTMLElement;\n      if (element) {\n        // This prevents a flash of focus on the first/last element in the collection\n        focusWithoutScrolling(element);\n        scrollIntoView(scrollRef.current, element);\n      }\n    }\n  };\n\n  let onBlur = (e) => {\n    // Don't set blurred and then focused again if moving focus within the collection.\n    if (!e.currentTarget.contains(e.relatedTarget as HTMLElement)) {\n      manager.setFocused(false);\n    }\n  };\n\n  const autoFocusRef = useRef(autoFocus);\n  useEffect(() => {\n    if (autoFocusRef.current) {\n      let focusedKey = null;\n\n      // Check focus strategy to determine which item to focus\n      if (autoFocus === 'first') {\n        focusedKey = delegate.getFirstKey();\n      } if (autoFocus === 'last') {\n        focusedKey = delegate.getLastKey();\n      }\n\n      // If there are any selected keys, make the first one the new focus target\n      let selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) {\n        focusedKey = selectedKeys.values().next().value;\n      }\n\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n\n      // If no default focus key is selected, focus the collection itself.\n      if (focusedKey == null && !shouldUseVirtualFocus) {\n        focusSafely(ref.current);\n      }\n    }\n    autoFocusRef.current = false;\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // If not virtualized, scroll the focused element into view when the focusedKey changes.\n  // When virtualized, Virtualizer handles this internally.\n  useEffect(() => {\n    if (!isVirtualized && manager.focusedKey && scrollRef?.current) {\n      let element = scrollRef.current.querySelector(`[data-key=\"${manager.focusedKey}\"]`) as HTMLElement;\n      if (element) {\n        scrollIntoView(scrollRef.current, element);\n      }\n    }\n  }, [isVirtualized, scrollRef, manager.focusedKey]);\n\n  let handlers = {\n    onKeyDown,\n    onFocus,\n    onBlur,\n    onMouseDown(e) {\n      // Ignore events that bubbled through portals.\n      if (e.currentTarget.contains(e.target)) {\n        // Prevent focus going to the collection when clicking on the scrollbar.\n        e.preventDefault();\n      }\n    }\n  };\n\n  let {typeSelectProps} = useTypeSelect({\n    keyboardDelegate: delegate,\n    selectionManager: manager\n  });\n\n  if (!disallowTypeAhead) {\n    handlers = mergeProps(typeSelectProps, handlers);\n  }\n\n  // If nothing is focused within the collection, make the collection itself tabbable.\n  // This will be marshalled to either the first or last item depending on where focus came from.\n  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try\n  // to move real DOM focus to the element anyway.\n  let tabIndex: number;\n  if (!shouldUseVirtualFocus) {\n    tabIndex = manager.focusedKey == null ? 0 : -1;\n  }\n\n  return {\n    collectionProps: {\n      ...handlers,\n      tabIndex\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {isAppleDevice} from '@react-aria/utils';\nimport {isMac} from '@react-aria/utils';\n\ninterface Event {\n  altKey: boolean,\n  ctrlKey: boolean,\n  metaKey: boolean\n}\n\nexport function isNonContiguousSelectionModifier(e: Event) {\n  // Ctrl + Arrow Up/Arrow Down has a system wide meaning on macOS, so use Alt instead.\n  // On Windows and Ubuntu, Alt + Space has a system wide meaning.\n  return isAppleDevice() ? e.altKey : e.ctrlKey;\n}\n\nexport function isCtrlKeyPressed(e: Event) {\n  if (isMac()) {\n    return e.metaKey;\n  }\n\n  return e.ctrlKey;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {HTMLAttributes, Key, KeyboardEvent, useRef} from 'react';\nimport {KeyboardDelegate} from '@react-types/shared';\nimport {MultipleSelectionManager} from '@react-stately/selection';\n\ninterface TypeSelectOptions {\n  /**\n   * A delegate that returns collection item keys with respect to visual layout.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * Called when an item is focused by typing.\n   */\n  onTypeSelect?: (key: Key) => void\n}\n\ninterface TypeSelectAria {\n  /**\n   * Props to be spread on the owner of the options.\n   */\n  typeSelectProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Handles typeahead interactions with collections.\n */\nexport function useTypeSelect(options: TypeSelectOptions): TypeSelectAria {\n  let {keyboardDelegate, selectionManager, onTypeSelect} = options;\n  let state = useRef({\n    search: '',\n    timeout: null\n  }).current;\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    let character = getStringForKey(e.key);\n    if (!character || e.ctrlKey || e.metaKey) {\n      return;\n    }\n\n    // Do not propagate the Spacebar event if it's meant to be part of the search.\n    // When we time out, the search term becomes empty, hence the check on length.\n    // Trimming is to account for the case of pressing the Spacebar more than once,\n    // which should cycle through the selection/deselection of the focused item.\n    if (character === ' ' && state.search.trim().length > 0) {\n      e.preventDefault();\n      if (!('continuePropagation' in e)) {\n        e.stopPropagation();\n      }\n    }\n\n    state.search += character;\n\n    // Use the delegate to find a key to focus.\n    // Prioritize items after the currently focused item, falling back to searching the whole list.\n    let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);\n\n    // If no key found, search from the top.\n    if (key == null) {\n      key = keyboardDelegate.getKeyForSearch(state.search);\n    }\n\n    if (key != null) {\n      selectionManager.setFocusedKey(key);\n      if (onTypeSelect) {\n        onTypeSelect(key);\n      }\n    }\n\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(() => {\n      state.search = '';\n    }, 500);\n  };\n\n  return {\n    typeSelectProps: {\n      // Using a capturing listener to catch the keydown event before\n      // other hooks in order to handle the Spacebar event.\n      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null\n    }\n  };\n}\n\nfunction getStringForKey(key: string) {\n  // If the key is of length 1, it is an ASCII value.\n  // Otherwise, if there are no ASCII characters in the key name,\n  // it is a Unicode character.\n  // See https://www.w3.org/TR/uievents-key/\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) {\n    return key;\n  }\n\n  return '';\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {focusSafely} from '@react-aria/focus';\nimport {HTMLAttributes, Key, RefObject, useEffect, useRef} from 'react';\nimport {isCtrlKeyPressed, isNonContiguousSelectionModifier} from './utils';\nimport {LongPressEvent, PressEvent} from '@react-types/shared';\nimport {mergeProps} from '@react-aria/utils';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {PressProps, useLongPress, usePress} from '@react-aria/interactions';\n\nexport interface SelectableItemOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A unique key for the item.\n   */\n  key: Key,\n  /**\n   * Ref to the item.\n   */\n  ref: RefObject<HTMLElement>,\n  /**\n   * By default, selection occurs on pointer down. This can be strange if selecting an\n   * item causes the UI to disappear immediately (e.g. menus).\n   */\n  shouldSelectOnPressUp?: boolean,\n  /**\n   * Whether selection requires the pointer/mouse down and up events to occur on the same target or triggers selection on\n   * the target of the pointer/mouse up event.\n   */\n  allowsDifferentPressOrigin?: boolean,\n  /**\n   * Whether the option is contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * Function to focus the item.\n   */\n  focus?: () => void,\n  /**\n   * Whether the option should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /** Whether the item is disabled. */\n  isDisabled?: boolean,\n  /**\n   * Handler that is called when a user performs an action on the item. The exact user event depends on\n   * the collection's `selectionBehavior` prop and the interaction modality.\n   */\n  onAction?: () => void\n}\n\nexport interface SelectableItemStates {\n  /** Whether the item is currently in a pressed state. */\n  isPressed: boolean,\n  /** Whether the item is currently selected. */\n  isSelected: boolean,\n  /**\n   * Whether the item is non-interactive, i.e. both selection and actions are disabled and the item may\n   * not be focused. Dependent on `disabledKeys` and `disabledBehavior`.\n   */\n  isDisabled: boolean,\n  /**\n   * Whether the item may be selected, dependent on `selectionMode`, `disabledKeys`, and `disabledBehavior`.\n   */\n  allowsSelection: boolean,\n  /**\n   * Whether the item has an action, dependent on `onAction`, `disabledKeys`,\n   * and `disabledBehavior. It may also change depending on the current selection state\n   * of the list (e.g. when selection is primary). This can be used to enable or disable hover\n   * styles or other visual indications of interactivity.\n   */\n  hasAction: boolean\n}\n\nexport interface SelectableItemAria extends SelectableItemStates {\n  /**\n   * Props to be spread on the item root node.\n   */\n  itemProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Handles interactions with an item in a selectable collection.\n */\nexport function useSelectableItem(options: SelectableItemOptions): SelectableItemAria {\n  let {\n    selectionManager: manager,\n    key,\n    ref,\n    shouldSelectOnPressUp,\n    isVirtualized,\n    shouldUseVirtualFocus,\n    focus,\n    isDisabled,\n    onAction,\n    allowsDifferentPressOrigin\n  } = options;\n\n  let onSelect = (e: PressEvent | LongPressEvent | PointerEvent) => {\n    if (e.pointerType === 'keyboard' && isNonContiguousSelectionModifier(e)) {\n      manager.toggleSelection(key);\n    } else {\n      if (manager.selectionMode === 'none') {\n        return;\n      }\n\n      if (manager.selectionMode === 'single') {\n        if (manager.isSelected(key) && !manager.disallowEmptySelection) {\n          manager.toggleSelection(key);\n        } else {\n          manager.replaceSelection(key);\n        }\n      } else if (e && e.shiftKey) {\n        manager.extendSelection(key);\n      } else if (manager.selectionBehavior === 'toggle' || (e && (isCtrlKeyPressed(e) || e.pointerType === 'touch' || e.pointerType === 'virtual'))) {\n        // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n        manager.toggleSelection(key);\n      } else {\n        manager.replaceSelection(key);\n      }\n    }\n  };\n\n  // Focus the associated DOM node when this item becomes the focusedKey\n  useEffect(() => {\n    let isFocused = key === manager.focusedKey;\n    if (isFocused && manager.isFocused && !shouldUseVirtualFocus && document.activeElement !== ref.current) {\n      if (focus) {\n        focus();\n      } else {\n        focusSafely(ref.current);\n      }\n    }\n  }, [ref, key, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]);\n\n  // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused\n  // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver\n  // on iOS 14 doesn't try to move real DOM focus to the item anyway.\n  let itemProps: SelectableItemAria['itemProps'] = {};\n  if (!shouldUseVirtualFocus) {\n    itemProps = {\n      tabIndex: key === manager.focusedKey ? 0 : -1,\n      onFocus(e) {\n        if (e.target === ref.current) {\n          manager.setFocusedKey(key);\n        }\n      }\n    };\n  }\n\n\n  // With checkbox selection, onAction (i.e. navigation) becomes primary, and occurs on a single click of the row.\n  // Clicking the checkbox enters selection mode, after which clicking anywhere on any row toggles selection for that row.\n  // With highlight selection, onAction is secondary, and occurs on double click. Single click selects the row.\n  // With touch, onAction occurs on single tap, and long press enters selection mode.\n  isDisabled = isDisabled || manager.isDisabled(key);\n  let allowsSelection = !isDisabled && manager.canSelectItem(key);\n  let allowsActions = onAction && !isDisabled;\n  let hasPrimaryAction = allowsActions && (\n    manager.selectionBehavior === 'replace'\n      ? !allowsSelection\n      : manager.isEmpty\n  );\n  let hasSecondaryAction = allowsActions && allowsSelection && manager.selectionBehavior === 'replace';\n  let hasAction = hasPrimaryAction || hasSecondaryAction;\n  let modality = useRef(null);\n\n  let longPressEnabled = hasAction && allowsSelection;\n  let longPressEnabledOnPressStart = useRef(false);\n  let hadPrimaryActionOnPressStart = useRef(false);\n\n  // By default, selection occurs on pointer down. This can be strange if selecting an\n  // item causes the UI to disappear immediately (e.g. menus).\n  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.\n  // onPress requires a pointer down event on the same element as pointer up. For menus,\n  // we want to be able to have the pointer down on the trigger that opens the menu and\n  // the pointer up on the menu item rather than requiring a separate press.\n  // For keyboard events, selection still occurs on key down.\n  let itemPressProps: PressProps = {};\n  if (shouldSelectOnPressUp) {\n    itemPressProps.onPressStart = (e) => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      if (e.pointerType === 'keyboard' && (!hasAction || isSelectionKey())) {\n        onSelect(e);\n      }\n    };\n\n    // If allowsDifferentPressOrigin, make selection happen on pressUp (e.g. open menu on press down, selection on menu item happens on press up.)\n    // Otherwise, have selection happen onPress (prevents listview row selection when clicking on interactable elements in the row)\n    if (!allowsDifferentPressOrigin) {\n      itemPressProps.onPress = (e) => {\n        if (hasPrimaryAction || (hasSecondaryAction && e.pointerType !== 'mouse')) {\n          if (e.pointerType === 'keyboard' && !isActionKey()) {\n            return;\n          }\n\n          onAction();\n        } else if (e.pointerType !== 'keyboard') {\n          onSelect(e);\n        }\n      };\n    } else {\n      itemPressProps.onPressUp = (e) => {\n        if (e.pointerType !== 'keyboard') {\n          onSelect(e);\n        }\n      };\n\n      itemPressProps.onPress = hasPrimaryAction ? () => onAction() : null;\n    }\n  } else {\n    itemPressProps.onPressStart = (e) => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      hadPrimaryActionOnPressStart.current = hasPrimaryAction;\n\n      // Select on mouse down unless there is a primary action which will occur on mouse up.\n      // For keyboard, select on key down. If there is an action, the Space key selects on key down,\n      // and the Enter key performs onAction on key up.\n      if (\n        (e.pointerType === 'mouse' && !hasPrimaryAction) ||\n        (e.pointerType === 'keyboard' && (!onAction || isSelectionKey()))\n      ) {\n        onSelect(e);\n      }\n    };\n\n    itemPressProps.onPress = (e) => {\n      // Selection occurs on touch up. Primary actions always occur on pointer up.\n      // Both primary and secondary actions occur on Enter key up. The only exception\n      // is secondary actions, which occur on double click with a mouse.\n      if (\n        e.pointerType === 'touch' ||\n        e.pointerType === 'pen' ||\n        e.pointerType === 'virtual' ||\n        (e.pointerType === 'keyboard' && hasAction && isActionKey()) ||\n        (e.pointerType === 'mouse' && hadPrimaryActionOnPressStart.current)\n      ) {\n        if (hasAction) {\n          onAction();\n        } else {\n          onSelect(e);\n        }\n      }\n    };\n  }\n\n  if (!isVirtualized) {\n    itemProps['data-key'] = key;\n  }\n\n  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;\n  let {pressProps, isPressed} = usePress(itemPressProps);\n\n  // Double clicking with a mouse with selectionBehavior = 'replace' performs an action.\n  let onDoubleClick = hasSecondaryAction ? (e) => {\n    if (modality.current === 'mouse') {\n      e.stopPropagation();\n      e.preventDefault();\n      onAction();\n    }\n  } : undefined;\n\n  // Long pressing an item with touch when selectionBehavior = 'replace' switches the selection behavior\n  // to 'toggle'. This changes the single tap behavior from performing an action (i.e. navigating) to\n  // selecting, and may toggle the appearance of a UI affordance like checkboxes on each item.\n  let {longPressProps} = useLongPress({\n    isDisabled: !longPressEnabled,\n    onLongPress(e) {\n      if (e.pointerType === 'touch') {\n        onSelect(e);\n        manager.setSelectionBehavior('toggle');\n      }\n    }\n  });\n\n  // Prevent native drag and drop on long press if we also select on long press.\n  // Once the user is in selection mode, they can long press again to drag.\n  let onDragStart = e => {\n    if (modality.current === 'touch' && longPressEnabledOnPressStart.current) {\n      e.preventDefault();\n    }\n  };\n\n  return {\n    itemProps: mergeProps(\n      itemProps,\n      allowsSelection || hasPrimaryAction ? pressProps : {},\n      longPressEnabled ? longPressProps : {},\n      {onDoubleClick, onDragStart}\n    ),\n    isPressed,\n    isSelected: manager.isSelected(key),\n    isDisabled,\n    allowsSelection,\n    hasAction\n  };\n}\n\nfunction isActionKey() {\n  let event = window.event as KeyboardEvent;\n  return event?.key === 'Enter';\n}\n\nfunction isSelectionKey() {\n  let event = window.event as KeyboardEvent;\n  return event?.key === ' ' || event?.code === 'Space';\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, FocusStrategy, KeyboardDelegate, Node} from '@react-types/shared';\nimport {HTMLAttributes, Key, RefObject, useMemo} from 'react';\nimport {ListKeyboardDelegate} from './ListKeyboardDelegate';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useCollator} from '@react-aria/i18n';\nimport {useSelectableCollection} from './useSelectableCollection';\n\ninterface SelectableListOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * State of the collection.\n   */\n  collection: Collection<Node<unknown>>,\n  /**\n   * The item keys that are disabled. These items cannot be selected, focused, or otherwise interacted with.\n   */\n  disabledKeys: Set<Key>,\n  /**\n   * A ref to the item.\n   */\n  ref?: RefObject<HTMLElement>,\n  /**\n   * A delegate that returns collection item keys with respect to visual layout.\n   */\n  keyboardDelegate?: KeyboardDelegate,\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy,\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean,\n  /**\n   * Whether the option is contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean,\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean,\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean,\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /**\n   * Whether navigation through tab key is enabled.\n   */\n  allowsTabNavigation?: boolean\n}\n\ninterface SelectableListAria {\n  /**\n   * Props for the option element.\n   */\n  listProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Handles interactions with a selectable list.\n */\nexport function useSelectableList(props: SelectableListOptions): SelectableListAria {\n  let {\n    selectionManager,\n    collection,\n    disabledKeys,\n    ref,\n    keyboardDelegate,\n    autoFocus,\n    shouldFocusWrap,\n    isVirtualized,\n    disallowEmptySelection,\n    selectOnFocus = false,\n    disallowTypeAhead,\n    shouldUseVirtualFocus,\n    allowsTabNavigation\n  } = props;\n\n  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n  let collator = useCollator({usage: 'search', sensitivity: 'base'});\n  let delegate = useMemo(() => keyboardDelegate || new ListKeyboardDelegate(collection, disabledKeys, ref, collator), [keyboardDelegate, collection, disabledKeys, ref, collator]);\n\n  let {collectionProps} = useSelectableCollection({\n    ref,\n    selectionManager,\n    keyboardDelegate: delegate,\n    autoFocus,\n    shouldFocusWrap,\n    disallowEmptySelection,\n    selectOnFocus,\n    disallowTypeAhead,\n    shouldUseVirtualFocus,\n    allowsTabNavigation,\n    isVirtualized,\n    scrollRef: ref\n  });\n\n  return {\n    listProps: collectionProps\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, KeyboardDelegate, Node} from '@react-types/shared';\nimport {Key, RefObject} from 'react';\n\nexport class ListKeyboardDelegate<T> implements KeyboardDelegate {\n  private collection: Collection<Node<T>>;\n  private disabledKeys: Set<Key>;\n  private ref: RefObject<HTMLElement>;\n  private collator: Intl.Collator;\n\n  constructor(collection: Collection<Node<T>>, disabledKeys: Set<Key>, ref: RefObject<HTMLElement>, collator?: Intl.Collator) {\n    this.collection = collection;\n    this.disabledKeys = disabledKeys;\n    this.ref = ref;\n    this.collator = collator;\n  }\n\n  getKeyBelow(key: Key) {\n    key = this.collection.getKeyAfter(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getKeyAbove(key: Key) {\n    key = this.collection.getKeyBefore(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  getFirstKey() {\n    let key = this.collection.getFirstKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getLastKey() {\n    let key = this.collection.getLastKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  private getItem(key: Key): HTMLElement {\n    return this.ref.current.querySelector(`[data-key=\"${key}\"]`);\n  }\n\n  getKeyPageAbove(key: Key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    let pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);\n\n    while (item && item.offsetTop > pageY) {\n      key = this.getKeyAbove(key);\n      item = this.getItem(key);\n    }\n\n    return key;\n  }\n\n  getKeyPageBelow(key: Key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    let pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);\n\n    while (item && item.offsetTop < pageY) {\n      key = this.getKeyBelow(key);\n      item = this.getItem(key);\n    }\n\n    return key;\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key) {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey || this.getFirstKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      let substring = item.textValue.slice(0, search.length);\n      if (item.textValue && this.collator.compare(substring, search) === 0) {\n        return key;\n      }\n\n      key = this.getKeyBelow(key);\n    }\n\n    return null;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}