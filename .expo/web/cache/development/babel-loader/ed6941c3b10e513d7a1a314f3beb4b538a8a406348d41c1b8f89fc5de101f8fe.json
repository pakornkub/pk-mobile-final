{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _wrapNativeSuper from \"@babel/runtime/helpers/wrapNativeSuper\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport { useRef as $Qsto2$useRef, useState as $Qsto2$useState, useMemo as $Qsto2$useMemo, useEffect as $Qsto2$useEffect } from \"react\";\nimport { useControlledState as $Qsto2$useControlledState } from \"@react-stately/utils\";\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\nvar $7af3f5b51489e0b5$exports = {};\n$parcel$export($7af3f5b51489e0b5$exports, \"useMultipleSelectionState\", function () {\n  return $7af3f5b51489e0b5$export$253fe78d46329472;\n});\nvar $e40ea825a81a3709$export$52baac22726c72bf = function (_Set) {\n  _inherits($e40ea825a81a3709$export$52baac22726c72bf, _Set);\n  var _super = _createSuper($e40ea825a81a3709$export$52baac22726c72bf);\n  function $e40ea825a81a3709$export$52baac22726c72bf(keys, anchorKey, currentKey) {\n    var _this;\n    _classCallCheck(this, $e40ea825a81a3709$export$52baac22726c72bf);\n    _this = _super.call(this, keys);\n    if (keys instanceof $e40ea825a81a3709$export$52baac22726c72bf) {\n      _this.anchorKey = anchorKey || keys.anchorKey;\n      _this.currentKey = currentKey || keys.currentKey;\n    } else {\n      _this.anchorKey = anchorKey;\n      _this.currentKey = currentKey;\n    }\n    return _this;\n  }\n  return _createClass($e40ea825a81a3709$export$52baac22726c72bf);\n}(_wrapNativeSuper(Set));\nfunction $7af3f5b51489e0b5$var$equalSets(setA, setB) {\n  if (setA.size !== setB.size) return false;\n  for (var item of setA) {\n    if (!setB.has(item)) return false;\n  }\n  return true;\n}\nfunction $7af3f5b51489e0b5$export$253fe78d46329472(props) {\n  var _props$selectionMode = props.selectionMode,\n    selectionMode = _props$selectionMode === void 0 ? 'none' : _props$selectionMode,\n    disallowEmptySelection = props.disallowEmptySelection,\n    allowDuplicateSelectionEvents = props.allowDuplicateSelectionEvents,\n    _props$selectionBehav = props.selectionBehavior,\n    selectionBehaviorProp = _props$selectionBehav === void 0 ? 'toggle' : _props$selectionBehav,\n    _props$disabledBehavi = props.disabledBehavior,\n    disabledBehavior = _props$disabledBehavi === void 0 ? 'all' : _props$disabledBehavi;\n  var isFocusedRef = $Qsto2$useRef(false);\n  var _$Qsto2$useState = $Qsto2$useState(false),\n    _$Qsto2$useState2 = _slicedToArray(_$Qsto2$useState, 2),\n    _setFocused = _$Qsto2$useState2[1];\n  var focusedKeyRef = $Qsto2$useRef(null);\n  var childFocusStrategyRef = $Qsto2$useRef(null);\n  var _$Qsto2$useState3 = $Qsto2$useState(null),\n    _$Qsto2$useState4 = _slicedToArray(_$Qsto2$useState3, 2),\n    _setFocusedKey = _$Qsto2$useState4[1];\n  var selectedKeysProp = $Qsto2$useMemo(function () {\n    return $7af3f5b51489e0b5$var$convertSelection(props.selectedKeys);\n  }, [props.selectedKeys]);\n  var defaultSelectedKeys = $Qsto2$useMemo(function () {\n    return $7af3f5b51489e0b5$var$convertSelection(props.defaultSelectedKeys, new $e40ea825a81a3709$export$52baac22726c72bf());\n  }, [props.defaultSelectedKeys]);\n  var _$Qsto2$useControlled = $Qsto2$useControlledState(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange),\n    _$Qsto2$useControlled2 = _slicedToArray(_$Qsto2$useControlled, 2),\n    selectedKeys = _$Qsto2$useControlled2[0],\n    _setSelectedKeys = _$Qsto2$useControlled2[1];\n  var disabledKeysProp = $Qsto2$useMemo(function () {\n    return props.disabledKeys ? new Set(props.disabledKeys) : new Set();\n  }, [props.disabledKeys]);\n  var _$Qsto2$useState5 = $Qsto2$useState(selectionBehaviorProp),\n    _$Qsto2$useState6 = _slicedToArray(_$Qsto2$useState5, 2),\n    selectionBehavior = _$Qsto2$useState6[0],\n    setSelectionBehavior = _$Qsto2$useState6[1];\n  if (selectionBehaviorProp === 'replace' && selectionBehavior === 'toggle' && typeof selectedKeys === 'object' && selectedKeys.size === 0) setSelectionBehavior('replace');\n  var lastSelectionBehavior = $Qsto2$useRef(selectionBehaviorProp);\n  $Qsto2$useEffect(function () {\n    if (selectionBehaviorProp !== lastSelectionBehavior.current) {\n      setSelectionBehavior(selectionBehaviorProp);\n      lastSelectionBehavior.current = selectionBehaviorProp;\n    }\n  }, [selectionBehaviorProp]);\n  return {\n    selectionMode: selectionMode,\n    disallowEmptySelection: disallowEmptySelection,\n    selectionBehavior: selectionBehavior,\n    setSelectionBehavior: setSelectionBehavior,\n    get isFocused() {\n      return isFocusedRef.current;\n    },\n    setFocused: function setFocused(f) {\n      isFocusedRef.current = f;\n      _setFocused(f);\n    },\n    get focusedKey() {\n      return focusedKeyRef.current;\n    },\n    get childFocusStrategy() {\n      return childFocusStrategyRef.current;\n    },\n    setFocusedKey: function setFocusedKey(k) {\n      var childFocusStrategy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'first';\n      focusedKeyRef.current = k;\n      childFocusStrategyRef.current = childFocusStrategy;\n      _setFocusedKey(k);\n    },\n    selectedKeys: selectedKeys,\n    setSelectedKeys: function setSelectedKeys(keys) {\n      if (allowDuplicateSelectionEvents || !$7af3f5b51489e0b5$var$equalSets(keys, selectedKeys)) _setSelectedKeys(keys);\n    },\n    disabledKeys: disabledKeysProp,\n    disabledBehavior: disabledBehavior\n  };\n}\nfunction $7af3f5b51489e0b5$var$convertSelection(selection, defaultValue) {\n  if (!selection) return defaultValue;\n  return selection === 'all' ? 'all' : new $e40ea825a81a3709$export$52baac22726c72bf(selection);\n}\nvar $d496c0a20b6e58ec$exports = {};\n$parcel$export($d496c0a20b6e58ec$exports, \"SelectionManager\", function () {\n  return $d496c0a20b6e58ec$export$6c8a5aaad13c9852;\n});\nvar $d496c0a20b6e58ec$export$6c8a5aaad13c9852 = function () {\n  function $d496c0a20b6e58ec$export$6c8a5aaad13c9852(collection, state, options) {\n    _classCallCheck(this, $d496c0a20b6e58ec$export$6c8a5aaad13c9852);\n    this.collection = collection;\n    this.state = state;\n    var ref;\n    this.allowsCellSelection = (ref = options === null || options === void 0 ? void 0 : options.allowsCellSelection) !== null && ref !== void 0 ? ref : false;\n    this._isSelectAll = null;\n  }\n  _createClass($d496c0a20b6e58ec$export$6c8a5aaad13c9852, [{\n    key: \"selectionMode\",\n    get: function get() {\n      return this.state.selectionMode;\n    }\n  }, {\n    key: \"disallowEmptySelection\",\n    get: function get() {\n      return this.state.disallowEmptySelection;\n    }\n  }, {\n    key: \"selectionBehavior\",\n    get: function get() {\n      return this.state.selectionBehavior;\n    }\n  }, {\n    key: \"setSelectionBehavior\",\n    value: function setSelectionBehavior(selectionBehavior) {\n      this.state.setSelectionBehavior(selectionBehavior);\n    }\n  }, {\n    key: \"isFocused\",\n    get: function get() {\n      return this.state.isFocused;\n    }\n  }, {\n    key: \"setFocused\",\n    value: function setFocused(isFocused) {\n      this.state.setFocused(isFocused);\n    }\n  }, {\n    key: \"focusedKey\",\n    get: function get() {\n      return this.state.focusedKey;\n    }\n  }, {\n    key: \"childFocusStrategy\",\n    get: function get() {\n      return this.state.childFocusStrategy;\n    }\n  }, {\n    key: \"setFocusedKey\",\n    value: function setFocusedKey(key, childFocusStrategy) {\n      this.state.setFocusedKey(key, childFocusStrategy);\n    }\n  }, {\n    key: \"selectedKeys\",\n    get: function get() {\n      return this.state.selectedKeys === 'all' ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;\n    }\n  }, {\n    key: \"rawSelection\",\n    get: function get() {\n      return this.state.selectedKeys;\n    }\n  }, {\n    key: \"isSelected\",\n    value: function isSelected(key) {\n      if (this.state.selectionMode === 'none') return false;\n      key = this.getKey(key);\n      return this.state.selectedKeys === 'all' ? this.canSelectItem(key) : this.state.selectedKeys.has(key);\n    }\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this.state.selectedKeys !== 'all' && this.state.selectedKeys.size === 0;\n    }\n  }, {\n    key: \"isSelectAll\",\n    get: function get() {\n      if (this.isEmpty) return false;\n      if (this.state.selectedKeys === 'all') return true;\n      if (this._isSelectAll != null) return this._isSelectAll;\n      var allKeys = this.getSelectAllKeys();\n      var selectedKeys = this.state.selectedKeys;\n      this._isSelectAll = allKeys.every(function (k) {\n        return selectedKeys.has(k);\n      });\n      return this._isSelectAll;\n    }\n  }, {\n    key: \"firstSelectedKey\",\n    get: function get() {\n      var first = null;\n      for (var key of this.state.selectedKeys) {\n        var item = this.collection.getItem(key);\n        if (!first || (item === null || item === void 0 ? void 0 : item.index) < first.index) first = item;\n      }\n      return first === null || first === void 0 ? void 0 : first.key;\n    }\n  }, {\n    key: \"lastSelectedKey\",\n    get: function get() {\n      var last = null;\n      for (var key of this.state.selectedKeys) {\n        var item = this.collection.getItem(key);\n        if (!last || (item === null || item === void 0 ? void 0 : item.index) > last.index) last = item;\n      }\n      return last === null || last === void 0 ? void 0 : last.key;\n    }\n  }, {\n    key: \"disabledKeys\",\n    get: function get() {\n      return this.state.disabledKeys;\n    }\n  }, {\n    key: \"disabledBehavior\",\n    get: function get() {\n      return this.state.disabledBehavior;\n    }\n  }, {\n    key: \"extendSelection\",\n    value: function extendSelection(toKey) {\n      if (this.selectionMode === 'none') return;\n      if (this.selectionMode === 'single') {\n        this.replaceSelection(toKey);\n        return;\n      }\n      toKey = this.getKey(toKey);\n      var selection;\n      if (this.state.selectedKeys === 'all') selection = new $e40ea825a81a3709$export$52baac22726c72bf([toKey], toKey, toKey);else {\n        var selectedKeys = this.state.selectedKeys;\n        var anchorKey = selectedKeys.anchorKey || toKey;\n        selection = new $e40ea825a81a3709$export$52baac22726c72bf(selectedKeys, anchorKey, toKey);\n        for (var key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey)) selection.delete(key);\n        for (var key1 of this.getKeyRange(toKey, anchorKey)) if (this.canSelectItem(key1)) selection.add(key1);\n      }\n      this.state.setSelectedKeys(selection);\n    }\n  }, {\n    key: \"getKeyRange\",\n    value: function getKeyRange(from, to) {\n      var fromItem = this.collection.getItem(from);\n      var toItem = this.collection.getItem(to);\n      if (fromItem && toItem) {\n        if (fromItem.index <= toItem.index) return this.getKeyRangeInternal(from, to);\n        return this.getKeyRangeInternal(to, from);\n      }\n      return [];\n    }\n  }, {\n    key: \"getKeyRangeInternal\",\n    value: function getKeyRangeInternal(from, to) {\n      var keys = [];\n      var key = from;\n      while (key) {\n        var item = this.collection.getItem(key);\n        if (item && item.type === 'item' || item.type === 'cell' && this.allowsCellSelection) keys.push(key);\n        if (key === to) return keys;\n        key = this.collection.getKeyAfter(key);\n      }\n      return [];\n    }\n  }, {\n    key: \"getKey\",\n    value: function getKey(key) {\n      var item = this.collection.getItem(key);\n      if (!item) return key;\n      if (item.type === 'cell' && this.allowsCellSelection) return key;\n      while (item.type !== 'item' && item.parentKey != null) item = this.collection.getItem(item.parentKey);\n      if (!item || item.type !== 'item') return null;\n      return item.key;\n    }\n  }, {\n    key: \"toggleSelection\",\n    value: function toggleSelection(key) {\n      if (this.selectionMode === 'none') return;\n      if (this.selectionMode === 'single' && !this.isSelected(key)) {\n        this.replaceSelection(key);\n        return;\n      }\n      key = this.getKey(key);\n      if (key == null) return;\n      var keys = new $e40ea825a81a3709$export$52baac22726c72bf(this.state.selectedKeys === 'all' ? this.getSelectAllKeys() : this.state.selectedKeys);\n      if (keys.has(key)) keys.delete(key);else if (this.canSelectItem(key)) {\n        keys.add(key);\n        keys.anchorKey = key;\n        keys.currentKey = key;\n      }\n      if (this.disallowEmptySelection && keys.size === 0) return;\n      this.state.setSelectedKeys(keys);\n    }\n  }, {\n    key: \"replaceSelection\",\n    value: function replaceSelection(key) {\n      if (this.selectionMode === 'none') return;\n      key = this.getKey(key);\n      if (key == null) return;\n      var selection = this.canSelectItem(key) ? new $e40ea825a81a3709$export$52baac22726c72bf([key], key, key) : new $e40ea825a81a3709$export$52baac22726c72bf();\n      this.state.setSelectedKeys(selection);\n    }\n  }, {\n    key: \"setSelectedKeys\",\n    value: function setSelectedKeys(keys) {\n      if (this.selectionMode === 'none') return;\n      var selection = new $e40ea825a81a3709$export$52baac22726c72bf();\n      for (var key of keys) {\n        key = this.getKey(key);\n        if (key != null) {\n          selection.add(key);\n          if (this.selectionMode === 'single') break;\n        }\n      }\n      this.state.setSelectedKeys(selection);\n    }\n  }, {\n    key: \"getSelectAllKeys\",\n    value: function getSelectAllKeys() {\n      var _this2 = this;\n      var keys = [];\n      var addKeys = function addKeys(key) {\n        while (key) {\n          if (_this2.canSelectItem(key)) {\n            var item = _this2.collection.getItem(key);\n            if (item.type === 'item') keys.push(key);\n            if (item.hasChildNodes && (_this2.allowsCellSelection || item.type !== 'item')) addKeys(_toConsumableArray(item.childNodes)[0].key);\n          }\n          key = _this2.collection.getKeyAfter(key);\n        }\n      };\n      addKeys(this.collection.getFirstKey());\n      return keys;\n    }\n  }, {\n    key: \"selectAll\",\n    value: function selectAll() {\n      if (this.selectionMode === 'multiple') this.state.setSelectedKeys('all');\n    }\n  }, {\n    key: \"clearSelection\",\n    value: function clearSelection() {\n      if (!this.disallowEmptySelection && (this.state.selectedKeys === 'all' || this.state.selectedKeys.size > 0)) this.state.setSelectedKeys(new $e40ea825a81a3709$export$52baac22726c72bf());\n    }\n  }, {\n    key: \"toggleSelectAll\",\n    value: function toggleSelectAll() {\n      if (this.isSelectAll) this.clearSelection();else this.selectAll();\n    }\n  }, {\n    key: \"select\",\n    value: function select(key, e) {\n      if (this.selectionMode === 'none') return;\n      if (this.selectionMode === 'single') {\n        if (this.isSelected(key) && !this.disallowEmptySelection) this.toggleSelection(key);else this.replaceSelection(key);\n      } else if (this.selectionBehavior === 'toggle' || e && (e.pointerType === 'touch' || e.pointerType === 'virtual')) this.toggleSelection(key);else this.replaceSelection(key);\n    }\n  }, {\n    key: \"isSelectionEqual\",\n    value: function isSelectionEqual(selection) {\n      if (selection === this.state.selectedKeys) return true;\n      var selectedKeys = this.selectedKeys;\n      if (selection.size !== selectedKeys.size) return false;\n      for (var key of selection) {\n        if (!selectedKeys.has(key)) return false;\n      }\n      for (var key2 of selectedKeys) {\n        if (!selection.has(key2)) return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"canSelectItem\",\n    value: function canSelectItem(key) {\n      if (this.state.selectionMode === 'none' || this.state.disabledKeys.has(key)) return false;\n      var item = this.collection.getItem(key);\n      if (!item || item.type === 'cell' && !this.allowsCellSelection) return false;\n      return true;\n    }\n  }, {\n    key: \"isDisabled\",\n    value: function isDisabled(key) {\n      return this.state.disabledKeys.has(key) && this.state.disabledBehavior === 'all';\n    }\n  }]);\n  return $d496c0a20b6e58ec$export$6c8a5aaad13c9852;\n}();\nvar $63d397230baf7bd4$exports = {};\nexport { $7af3f5b51489e0b5$export$253fe78d46329472 as useMultipleSelectionState, $d496c0a20b6e58ec$export$6c8a5aaad13c9852 as SelectionManager };","map":{"version":3,"names":["$e40ea825a81a3709$export$52baac22726c72bf","_Set","_inherits","_super","_createSuper","keys","anchorKey","currentKey","_this","_classCallCheck","call","_createClass","_wrapNativeSuper","Set","$7af3f5b51489e0b5$var$equalSets","setA","setB","size","item","has","$7af3f5b51489e0b5$export$253fe78d46329472","props","_props$selectionMode","selectionMode","disallowEmptySelection","allowDuplicateSelectionEvents","_props$selectionBehav","selectionBehavior","selectionBehaviorProp","_props$disabledBehavi","disabledBehavior","isFocusedRef","$Qsto2$useRef","_$Qsto2$useState","$Qsto2$useState","_$Qsto2$useState2","_slicedToArray","setFocused","focusedKeyRef","childFocusStrategyRef","_$Qsto2$useState3","_$Qsto2$useState4","setFocusedKey","selectedKeysProp","$Qsto2$useMemo","$7af3f5b51489e0b5$var$convertSelection","selectedKeys","defaultSelectedKeys","_$Qsto2$useControlled","$Qsto2$useControlledState","onSelectionChange","_$Qsto2$useControlled2","setSelectedKeys","disabledKeysProp","disabledKeys","_$Qsto2$useState5","_$Qsto2$useState6","setSelectionBehavior","lastSelectionBehavior","$Qsto2$useEffect","current","isFocused","f","focusedKey","childFocusStrategy","k","arguments","length","undefined","selection","defaultValue","$d496c0a20b6e58ec$export$6c8a5aaad13c9852","collection","state","options","ref","allowsCellSelection","_isSelectAll","key","get","value","getSelectAllKeys","isSelected","getKey","canSelectItem","isEmpty","allKeys","every","first","getItem","index","last","extendSelection","toKey","replaceSelection","getKeyRange","delete","key1","add","from","to","fromItem","toItem","getKeyRangeInternal","type","push","getKeyAfter","parentKey","toggleSelection","_this2","addKeys","hasChildNodes","_toConsumableArray","childNodes","getFirstKey","selectAll","clearSelection","toggleSelectAll","isSelectAll","select","e","pointerType","isSelectionEqual","key2","isDisabled"],"sources":["D:\\_Dev\\expo\\pk-mobile\\node_modules\\@react-stately\\selection\\dist\\packages\\@react-stately\\selection\\src\\index.ts","D:\\_Dev\\expo\\pk-mobile\\node_modules\\@react-stately\\selection\\dist\\packages\\@react-stately\\selection\\src\\useMultipleSelectionState.ts","D:\\_Dev\\expo\\pk-mobile\\node_modules\\@react-stately\\selection\\dist\\packages\\@react-stately\\selection\\src\\Selection.ts","D:\\_Dev\\expo\\pk-mobile\\node_modules\\@react-stately\\selection\\dist\\packages\\@react-stately\\selection\\src\\SelectionManager.ts","D:\\_Dev\\expo\\pk-mobile\\node_modules\\@react-stately\\selection\\dist\\packages\\@react-stately\\selection\\src\\types.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport * from './useMultipleSelectionState';\nexport * from './SelectionManager';\nexport * from './types';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DisabledBehavior, MultipleSelection, SelectionBehavior, SelectionMode} from '@react-types/shared';\nimport {Key, useEffect, useMemo, useRef, useState} from 'react';\nimport {MultipleSelectionState} from './types';\nimport {Selection} from './Selection';\nimport {useControlledState} from '@react-stately/utils';\n\nfunction equalSets(setA, setB) {\n  if (setA.size !== setB.size) {\n    return false;\n  }\n\n  for (let item of setA) {\n    if (!setB.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport interface MultipleSelectionStateProps extends MultipleSelection {\n  /** How multiple selection should behave in the collection. */\n  selectionBehavior?: SelectionBehavior,\n  /** Whether onSelectionChange should fire even if the new set of keys is the same as the last. */\n  allowDuplicateSelectionEvents?: boolean,\n  /** Whether `disabledKeys` applies to all interactions, or only selection. */\n  disabledBehavior?: DisabledBehavior\n}\n\n/**\n * Manages state for multiple selection and focus in a collection.\n */\nexport function useMultipleSelectionState(props: MultipleSelectionStateProps): MultipleSelectionState {\n  let {\n    selectionMode = 'none' as SelectionMode,\n    disallowEmptySelection,\n    allowDuplicateSelectionEvents,\n    selectionBehavior: selectionBehaviorProp = 'toggle',\n    disabledBehavior = 'all'\n  } = props;\n\n  // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.\n  // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).\n  let isFocusedRef = useRef(false);\n  let [, setFocused] = useState(false);\n  let focusedKeyRef = useRef(null);\n  let childFocusStrategyRef = useRef(null);\n  let [, setFocusedKey] = useState(null);\n  let selectedKeysProp = useMemo(() => convertSelection(props.selectedKeys), [props.selectedKeys]);\n  let defaultSelectedKeys = useMemo(() => convertSelection(props.defaultSelectedKeys, new Selection()), [props.defaultSelectedKeys]);\n  let [selectedKeys, setSelectedKeys] = useControlledState(\n    selectedKeysProp,\n    defaultSelectedKeys,\n    props.onSelectionChange\n  );\n  let disabledKeysProp = useMemo(() =>\n    props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n  , [props.disabledKeys]);\n  let [selectionBehavior, setSelectionBehavior] = useState(selectionBehaviorProp);\n\n  // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press\n  // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.\n  if (selectionBehaviorProp === 'replace' && selectionBehavior === 'toggle' && typeof selectedKeys === 'object' && selectedKeys.size === 0) {\n    setSelectionBehavior('replace');\n  }\n\n  // If the selectionBehavior prop changes, update the state as well.\n  let lastSelectionBehavior = useRef(selectionBehaviorProp);\n  useEffect(() => {\n    if (selectionBehaviorProp !== lastSelectionBehavior.current) {\n      setSelectionBehavior(selectionBehaviorProp);\n      lastSelectionBehavior.current = selectionBehaviorProp;\n    }\n  }, [selectionBehaviorProp]);\n\n  return {\n    selectionMode,\n    disallowEmptySelection,\n    selectionBehavior,\n    setSelectionBehavior,\n    get isFocused() {\n      return isFocusedRef.current;\n    },\n    setFocused(f) {\n      isFocusedRef.current = f;\n      setFocused(f);\n    },\n    get focusedKey() {\n      return focusedKeyRef.current;\n    },\n    get childFocusStrategy() {\n      return childFocusStrategyRef.current;\n    },\n    setFocusedKey(k, childFocusStrategy = 'first') {\n      focusedKeyRef.current = k;\n      childFocusStrategyRef.current = childFocusStrategy;\n      setFocusedKey(k);\n    },\n    selectedKeys,\n    setSelectedKeys(keys) {\n      if (allowDuplicateSelectionEvents || !equalSets(keys, selectedKeys)) {\n        setSelectedKeys(keys);\n      }\n    },\n    disabledKeys: disabledKeysProp,\n    disabledBehavior\n  };\n}\n\nfunction convertSelection(selection: 'all' | Iterable<Key>, defaultValue?: Selection): 'all' | Selection {\n  if (!selection) {\n    return defaultValue;\n  }\n\n  return selection === 'all'\n    ? 'all'\n    : new Selection(selection);\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\n\n/**\n * A Selection is a special Set containing Keys, which also has an anchor\n * and current selected key for use when range selecting.\n */\nexport class Selection extends Set<Key> {\n  anchorKey: Key;\n  currentKey: Key;\n\n  constructor(keys?: Iterable<Key> | Selection, anchorKey?: Key, currentKey?: Key) {\n    super(keys);\n    if (keys instanceof Selection) {\n      this.anchorKey = anchorKey || keys.anchorKey;\n      this.currentKey = currentKey || keys.currentKey;\n    } else {\n      this.anchorKey = anchorKey;\n      this.currentKey = currentKey;\n    }\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n  Collection,\n  DisabledBehavior,\n  FocusStrategy,\n  Selection as ISelection,\n  LongPressEvent,\n  Node,\n  PressEvent,\n  SelectionBehavior,\n  SelectionMode\n} from '@react-types/shared';\nimport {Key} from 'react';\nimport {MultipleSelectionManager, MultipleSelectionState} from './types';\nimport {Selection} from './Selection';\n\ninterface SelectionManagerOptions {\n  allowsCellSelection?: boolean\n}\n\n/**\n * An interface for reading and updating multiple selection state.\n */\nexport class SelectionManager implements MultipleSelectionManager {\n  private collection: Collection<Node<unknown>>;\n  private state: MultipleSelectionState;\n  private allowsCellSelection: boolean;\n  private _isSelectAll: boolean;\n\n  constructor(collection: Collection<Node<unknown>>, state: MultipleSelectionState, options?: SelectionManagerOptions) {\n    this.collection = collection;\n    this.state = state;\n    this.allowsCellSelection = options?.allowsCellSelection ?? false;\n    this._isSelectAll = null;\n  }\n\n  /**\n   * The type of selection that is allowed in the collection.\n   */\n  get selectionMode(): SelectionMode {\n    return this.state.selectionMode;\n  }\n\n  /**\n   * Whether the collection allows empty selection.\n   */\n  get disallowEmptySelection(): boolean {\n    return this.state.disallowEmptySelection;\n  }\n\n  /**\n   * The selection behavior for the collection.\n   */\n  get selectionBehavior(): SelectionBehavior {\n    return this.state.selectionBehavior;\n  }\n\n  /**\n   * Sets the selection behavior for the collection.\n   */\n  setSelectionBehavior(selectionBehavior: SelectionBehavior) {\n    this.state.setSelectionBehavior(selectionBehavior);\n  }\n\n  /**\n   * Whether the collection is currently focused.\n   */\n  get isFocused(): boolean {\n    return this.state.isFocused;\n  }\n\n  /**\n   * Sets whether the collection is focused.\n   */\n  setFocused(isFocused: boolean) {\n    this.state.setFocused(isFocused);\n  }\n\n  /**\n   * The current focused key in the collection.\n   */\n  get focusedKey(): Key {\n    return this.state.focusedKey;\n  }\n\n  /** Whether the first or last child of the focused key should receive focus. */\n  get childFocusStrategy(): FocusStrategy {\n    return this.state.childFocusStrategy;\n  }\n\n  /**\n   * Sets the focused key.\n   */\n  setFocusedKey(key: Key, childFocusStrategy?: FocusStrategy) {\n    this.state.setFocusedKey(key, childFocusStrategy);\n  }\n\n  /**\n   * The currently selected keys in the collection.\n   */\n  get selectedKeys(): Set<Key> {\n    return this.state.selectedKeys === 'all'\n      ? new Set(this.getSelectAllKeys())\n      : this.state.selectedKeys;\n  }\n\n  /**\n   * The raw selection value for the collection.\n   * Either 'all' for select all, or a set of keys.\n   */\n  get rawSelection(): ISelection {\n    return this.state.selectedKeys;\n  }\n\n  /**\n   * Returns whether a key is selected.\n   */\n  isSelected(key: Key) {\n    if (this.state.selectionMode === 'none') {\n      return false;\n    }\n\n    key = this.getKey(key);\n    return this.state.selectedKeys === 'all'\n      ? this.canSelectItem(key)\n      : this.state.selectedKeys.has(key);\n  }\n\n  /**\n   * Whether the selection is empty.\n   */\n  get isEmpty(): boolean {\n    return this.state.selectedKeys !== 'all' && this.state.selectedKeys.size === 0;\n  }\n\n  /**\n   * Whether all items in the collection are selected.\n   */\n  get isSelectAll(): boolean {\n    if (this.isEmpty) {\n      return false;\n    }\n\n    if (this.state.selectedKeys === 'all') {\n      return true;\n    }\n\n    if (this._isSelectAll != null) {\n      return this._isSelectAll;\n    }\n\n    let allKeys = this.getSelectAllKeys();\n    let selectedKeys = this.state.selectedKeys;\n    this._isSelectAll = allKeys.every(k => selectedKeys.has(k));\n    return this._isSelectAll;\n  }\n\n  get firstSelectedKey(): Key | null {\n    let first: Node<unknown> | null = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!first || item?.index < first.index) {\n        first = item;\n      }\n    }\n\n    return first?.key;\n  }\n\n  get lastSelectedKey(): Key | null {\n    let last: Node<unknown> | null = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!last || item?.index > last.index) {\n        last = item;\n      }\n    }\n\n    return last?.key;\n  }\n\n  get disabledKeys(): Set<Key> {\n    return this.state.disabledKeys;\n  }\n\n  get disabledBehavior(): DisabledBehavior {\n    return this.state.disabledBehavior;\n  }\n\n  /**\n   * Extends the selection to the given key.\n   */\n  extendSelection(toKey: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single') {\n      this.replaceSelection(toKey);\n      return;\n    }\n\n    toKey = this.getKey(toKey);\n\n    let selection: Selection;\n\n    // Only select the one key if coming from a select all.\n    if (this.state.selectedKeys === 'all') {\n      selection = new Selection([toKey], toKey, toKey);\n    } else {\n      let selectedKeys = this.state.selectedKeys as Selection;\n      let anchorKey = selectedKeys.anchorKey || toKey;\n      selection = new Selection(selectedKeys, anchorKey, toKey);\n      for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey)) {\n        selection.delete(key);\n      }\n\n      for (let key of this.getKeyRange(toKey, anchorKey)) {\n        if (this.canSelectItem(key)) {\n          selection.add(key);\n        }\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  private getKeyRange(from: Key, to: Key) {\n    let fromItem = this.collection.getItem(from);\n    let toItem = this.collection.getItem(to);\n    if (fromItem && toItem) {\n      if (fromItem.index <= toItem.index) {\n        return this.getKeyRangeInternal(from, to);\n      }\n\n      return this.getKeyRangeInternal(to, from);\n    }\n\n    return [];\n  }\n\n  private getKeyRangeInternal(from: Key, to: Key) {\n    let keys: Key[] = [];\n    let key = from;\n    while (key) {\n      let item = this.collection.getItem(key);\n      if (item && item.type === 'item' || (item.type === 'cell' && this.allowsCellSelection)) {\n        keys.push(key);\n      }\n\n      if (key === to) {\n        return keys;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n\n    return [];\n  }\n\n  private getKey(key: Key) {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      // ¯\\_(ツ)_/¯\n      return key;\n    }\n\n    // If cell selection is allowed, just return the key.\n    if (item.type === 'cell' && this.allowsCellSelection) {\n      return key;\n    }\n\n    // Find a parent item to select\n    while (item.type !== 'item' && item.parentKey != null) {\n      item = this.collection.getItem(item.parentKey);\n    }\n\n    if (!item || item.type !== 'item') {\n      return null;\n    }\n\n    return item.key;\n  }\n\n  /**\n   * Toggles whether the given key is selected.\n   */\n  toggleSelection(key: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single' && !this.isSelected(key)) {\n      this.replaceSelection(key);\n      return;\n    }\n\n    key = this.getKey(key);\n    if (key == null) {\n      return;\n    }\n\n    let keys = new Selection(this.state.selectedKeys === 'all' ? this.getSelectAllKeys() : this.state.selectedKeys);\n    if (keys.has(key)) {\n      keys.delete(key);\n      // TODO: move anchor to last selected key...\n      // Does `current` need to move here too?\n    } else if (this.canSelectItem(key)) {\n      keys.add(key);\n      keys.anchorKey = key;\n      keys.currentKey = key;\n    }\n\n    if (this.disallowEmptySelection && keys.size === 0) {\n      return;\n    }\n\n    this.state.setSelectedKeys(keys);\n  }\n\n  /**\n   * Replaces the selection with only the given key.\n   */\n  replaceSelection(key: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    key = this.getKey(key);\n    if (key == null) {\n      return;\n    }\n\n    let selection = this.canSelectItem(key)\n      ? new Selection([key], key, key)\n      : new Selection();\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  /**\n   * Replaces the selection with the given keys.\n   */\n  setSelectedKeys(keys: Iterable<Key>) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    let selection = new Selection();\n    for (let key of keys) {\n      key = this.getKey(key);\n      if (key != null) {\n        selection.add(key);\n        if (this.selectionMode === 'single') {\n          break;\n        }\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  private getSelectAllKeys() {\n    let keys: Key[] = [];\n    let addKeys = (key: Key) => {\n      while (key) {\n        if (this.canSelectItem(key)) {\n          let item = this.collection.getItem(key);\n          if (item.type === 'item') {\n            keys.push(key);\n          }\n\n          // Add child keys. If cell selection is allowed, then include item children too.\n          if (item.hasChildNodes && (this.allowsCellSelection || item.type !== 'item')) {\n            addKeys([...item.childNodes][0].key);\n          }\n        }\n\n        key = this.collection.getKeyAfter(key);\n      }\n    };\n\n    addKeys(this.collection.getFirstKey());\n    return keys;\n  }\n\n  /**\n   * Selects all items in the collection.\n   */\n  selectAll() {\n    if (this.selectionMode === 'multiple') {\n      this.state.setSelectedKeys('all');\n    }\n  }\n\n  /**\n   * Removes all keys from the selection.\n   */\n  clearSelection() {\n    if (!this.disallowEmptySelection && (this.state.selectedKeys === 'all' || this.state.selectedKeys.size > 0)) {\n      this.state.setSelectedKeys(new Selection());\n    }\n  }\n\n  /**\n   * Toggles between select all and an empty selection.\n   */\n  toggleSelectAll() {\n    if (this.isSelectAll) {\n      this.clearSelection();\n    } else {\n      this.selectAll();\n    }\n  }\n\n  select(key: Key, e?: PressEvent | LongPressEvent | PointerEvent) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single') {\n      if (this.isSelected(key) && !this.disallowEmptySelection) {\n        this.toggleSelection(key);\n      } else {\n        this.replaceSelection(key);\n      }\n    } else if (this.selectionBehavior === 'toggle' || (e && (e.pointerType === 'touch' || e.pointerType === 'virtual'))) {\n      // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n      this.toggleSelection(key);\n    } else {\n      this.replaceSelection(key);\n    }\n  }\n\n  /**\n   * Returns whether the current selection is equal to the given selection.\n   */\n  isSelectionEqual(selection: Set<Key>) {\n    if (selection === this.state.selectedKeys) {\n      return true;\n    }\n\n    // Check if the set of keys match.\n    let selectedKeys = this.selectedKeys;\n    if (selection.size !== selectedKeys.size) {\n      return false;\n    }\n\n    for (let key of selection) {\n      if (!selectedKeys.has(key)) {\n        return false;\n      }\n    }\n\n    for (let key of selectedKeys) {\n      if (!selection.has(key)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  canSelectItem(key: Key) {\n    if (this.state.selectionMode === 'none' || this.state.disabledKeys.has(key)) {\n      return false;\n    }\n\n    let item = this.collection.getItem(key);\n    if (!item || (item.type === 'cell' && !this.allowsCellSelection)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  isDisabled(key: Key) {\n    return this.state.disabledKeys.has(key) && this.state.disabledBehavior === 'all';\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DisabledBehavior, FocusStrategy, LongPressEvent, PressEvent, Selection, SelectionBehavior, SelectionMode} from '@react-types/shared';\nimport {Key} from 'react';\n\nexport interface FocusState {\n  /** Whether the collection is currently focused. */\n  readonly isFocused: boolean,\n  /** Sets whether the collection is focused. */\n  setFocused(isFocused: boolean): void,\n  /** The current focused key in the collection. */\n  readonly focusedKey: Key,\n  /** Whether the first or last child of the focused key should receive focus. */\n  readonly childFocusStrategy: FocusStrategy,\n  /** Sets the focused key, and optionally, whether the first or last child of that key should receive focus. */\n  setFocusedKey(key: Key, child?: FocusStrategy): void\n}\n\nexport interface SingleSelectionState extends FocusState {\n  /** Whether the collection allows empty selection. */\n  readonly disallowEmptySelection?: boolean,\n  /** The currently selected key in the collection. */\n  readonly selectedKey: Key,\n  /** Sets the selected key in the collection. */\n  setSelectedKey(key: Key): void\n}\n\nexport interface MultipleSelectionState extends FocusState {\n  /** The type of selection that is allowed in the collection. */\n  readonly selectionMode: SelectionMode,\n  /** The selection behavior for the collection. */\n  readonly selectionBehavior: SelectionBehavior,\n  /** Sets the selection behavior for the collection. */\n  setSelectionBehavior(selectionBehavior: SelectionBehavior): void,\n  /** Whether the collection allows empty selection. */\n  readonly disallowEmptySelection: boolean,\n  /** The currently selected keys in the collection. */\n  readonly selectedKeys: Selection,\n  /** Sets the selected keys in the collection. */\n  setSelectedKeys(keys: Selection): void,\n  /** The currently disabled keys in the collection. */\n  readonly disabledKeys: Set<Key>,\n  /** Whether `disabledKeys` applies to selection, actions, or both. */\n  readonly disabledBehavior: DisabledBehavior\n}\n\nexport interface MultipleSelectionManager extends FocusState {\n  /** The type of selection that is allowed in the collection. */\n  readonly selectionMode: SelectionMode,\n  /** The selection behavior for the collection. */\n  readonly selectionBehavior: SelectionBehavior,\n  /** Whether the collection allows empty selection. */\n  readonly disallowEmptySelection?: boolean,\n  /** The currently selected keys in the collection. */\n  readonly selectedKeys: Set<Key>,\n  /** Whether the selection is empty. */\n  readonly isEmpty: boolean,\n  /** Whether all items in the collection are selected. */\n  readonly isSelectAll: boolean,\n  /** The first selected key in the collection. */\n  readonly firstSelectedKey: Key | null,\n  /** The last selected key in the collection. */\n  readonly lastSelectedKey: Key | null,\n  /** The currently disabled keys in the collection. */\n  readonly disabledKeys: Set<Key>,\n  /** Whether `disabledKeys` applies to selection, actions, or both. */\n  readonly disabledBehavior: DisabledBehavior,\n  /** Returns whether a key is selected. */\n  isSelected(key: Key): boolean,\n  /** Returns whether the current selection is equal to the given selection. */\n  isSelectionEqual(selection: Set<Key>): boolean,\n  /** Extends the selection to the given key. */\n  extendSelection(toKey: Key): void,\n  /** Toggles whether the given key is selected. */\n  toggleSelection(key: Key): void,\n  /** Replaces the selection with only the given key. */\n  replaceSelection(key: Key): void,\n  /** Replaces the selection with the given keys. */\n  setSelectedKeys(keys: Iterable<Key>): void,\n  /** Selects all items in the collection. */\n  selectAll(): void,\n  /** Removes all keys from the selection. */\n  clearSelection(): void,\n  /** Toggles between select all and an empty selection. */\n  toggleSelectAll(): void,\n  /**\n   * Toggles, replaces, or extends selection to the given key depending\n   * on the pointer event and collection's selection mode.\n   */\n  select(key: Key, e?: PressEvent | LongPressEvent | PointerEvent): void,\n  /** Returns whether the given key can be selected. */\n  canSelectItem(key: Key): boolean,\n  /** Returns whether the given key is non-interactive, i.e. both selection and actions are disabled. */\n  isDisabled(key: Key): boolean,\n  /** Sets the selection behavior for the collection. */\n  setSelectionBehavior(selectionBehavior: SelectionBehavior): void\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}